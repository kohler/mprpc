// -*- mode: c++ -*-
#ifndef MPVR_THH
#define MPVR_THH 1
#include "string.hh"
#include "circular_int.hh"
#include <unordered_map>
#include <random>
#include <iostream>
using tamer::event;

class Vrchannel {
  public:
    inline Vrchannel(String local_uid, String remote_uid)
        : local_uid_(std::move(local_uid)), remote_uid_(std::move(remote_uid)),
          connection_version_(0) {
    }
    virtual ~Vrchannel() {
    }

    inline const String& local_uid() const {
        return local_uid_;
    }
    inline const String& remote_uid() const {
        return remote_uid_;
    }
    inline const String& connection_uid() const {
        return connection_uid_;
    }
    inline void set_connection_uid(String x) {
        connection_uid_ = std::move(x);
    }
    inline unsigned connection_version() const {
        return connection_version_;
    }
    virtual Json local_name() const;
    virtual Json remote_name() const;

    static String make_client_uid();
    static String make_replica_uid();

    virtual void connect(String peer_uid, event<Vrchannel*> done);
    virtual void receive_connection(event<Vrchannel*> done);

    virtual void send(Json msg);
    virtual void receive(event<Json> done);
    virtual void close();

    void print_receive(const Json& msg);

  protected:
    String local_uid_;
    String remote_uid_;
    String connection_uid_;
    unsigned connection_version_;

    void print_message(bool issend, const Json& msg);
};


class Vrnode {
  public:
    typedef circular_int<unsigned> viewnumber_t;
    typedef viewnumber_t::difference_type viewnumberdiff_t;
    typedef circular_int<unsigned> lognumber_t;
    typedef lognumber_t::difference_type lognumberdiff_t;

    Vrnode(const String& group_name, Vrchannel* me, std::mt19937& rg);

    String group_name() const {
        return group_name_;
    }
    String uid() const {
        return me_ ? me_->local_uid() : String();
    }
    viewnumber_t view_number() const {
        return cur_view_.viewno;
    }

    tamed void connect(String peer_uid, event<> done);
    tamed void join(String peer_uid, event<> done);

    void at_view(viewnumber_t viewno, tamer::event<> done);
    void at_store(lognumber_t storeno, tamer::event<> done);
    void at_commit(lognumber_t commitno, tamer::event<> done);

    void stop();
    void go();

    void dump(std::ostream&) const;

    inline std::ostream& log() const;
    inline std::ostream& log_send(Vrchannel*) const;
    inline std::ostream& log_receive(Vrchannel*) const;
    inline std::ostream& log_connection(Vrchannel*) const;
    inline std::ostream& log_connection(Vrchannel*, const char* ctype) const;

  private:
    String group_name_;

    struct view_member {
        String uid;
        Json peer_name;
        bool acked;
        bool confirmed;
        bool has_storeno;
        lognumber_t storeno;
        unsigned store_count;
        explicit view_member(String peer_uid, Json peer_name)
            : uid(std::move(peer_uid)), peer_name(std::move(peer_name)),
              acked(false), confirmed(false),
              has_storeno(false), store_count(0) {
            assert(!this->peer_name["uid"] || this->peer_name["uid"] == uid);
            this->peer_name["uid"] = this->uid;
        }
    };

    struct view_type {
        viewnumber_t viewno;
        std::vector<view_member> members;
        int primary_index;
        int my_index;
        unsigned nacked;
        unsigned nconfirmed;

        view_type();
        static view_type make_singular(String peer_uid);

        inline unsigned size() const {
            return members.size();
        }
        inline unsigned f() const {
            return size() / 2;
        }
        inline bool me_primary() const {
            return primary_index == my_index;
        }
        inline view_member& primary() {
            return members[primary_index];
        }
        inline String primary_uid() const {
            return members[primary_index].uid;
        }

        inline int count(const String& uid) const;
        inline view_member* find_pointer(const String& uid);
        Json members_json() const;
        Json commits_json() const;
        bool assign(Json msg, const String& my_uid);
        //inline Json operator[](const String& uid) const;
        bool operator==(const view_type& x) const;
        bool operator!=(const view_type& x) const { return !(*this == x); }
        bool shared_quorum(const view_type& x) const;
        void prepare(String uid, const Json& payload);
        void clear_preparation();
        void add(String uid, const String& my_uid);
        void advance();
        void account_commit(view_member* peer, lognumber_t commitno);
        bool account_all_commits();
    };

    view_type cur_view_;
    view_type next_view_;
    bool want_member_;

    Vrchannel* me_;
    mutable std::unordered_map<String, Vrchannel*> endpoints_;
    mutable std::unordered_map<String, tamer::event<> > connection_wait_;

    struct log_item {
        viewnumber_t viewno;
        String client_uid;
        unsigned client_seqno;
        Json request;
        log_item() {
        }
        log_item(viewnumber_t v, String cuid, unsigned cseqno, Json req)
            : viewno(v), client_uid(std::move(cuid)), client_seqno(cseqno),
              request(std::move(req)) {
        }
    };

    lognumber_t first_logno_;
    lognumber_t commitno_;
    lognumber_t complete_commitno_;
    lognumber_t broadcast_commitno_;
    std::deque<log_item> log_;

    bool next_view_sent_confirm_;

    bool stopped_;

    std::deque<std::pair<viewnumber_t, tamer::event<> > > at_view_;
    std::deque<std::pair<lognumber_t, tamer::event<> > > at_store_;
    std::deque<std::pair<lognumber_t, tamer::event<> > > at_commit_;

    // timeouts
    double message_timeout_;
    double handshake_timeout_;
    double primary_keepalive_timeout_;
    double backup_keepalive_timeout_;
    double view_change_timeout_;

    double commit_sent_at_;
    double primary_received_at_;
    std::mt19937& rg_;

    inline bool is_primary() const {
        return cur_view_.me_primary();
    }
    inline bool in_view(viewnumber_t v) const {
        return cur_view_.viewno == v
            && (next_view_.viewno == v || !next_view_sent_confirm_);
    }
    inline bool between_views() const {
        return cur_view_.viewno != next_view_.viewno
            && next_view_sent_confirm_;
    }
    inline double rand01() const {
        std::uniform_real_distribution<double> urd;
        return urd(rg_);
    }

    String unparse_view_state() const;

    Json view_payload(const String& peer_uid);
    void send_view(Vrchannel* who, Json payload = Json(), Json seqno = Json());
    tamed void send_view(String peer_uid);
    tamed void start_view_change();
    void broadcast_view();
    void process_join(Vrchannel* who, const Json& msg);
    void process_view(Vrchannel* who, const Json& msg);
    void process_view_log_transfer(Json& payload);
    void process_request(Vrchannel* who, const Json& msg);
    void process_replicate(Vrchannel* who, const Json& msg);
    void process_commit(Vrchannel* who, const Json& msg);
    void update_commitno(lognumber_t commitno);
    inline Json commit_message() const;
    Json commit_log_message(lognumber_t from_storeno) const;
    void send_commit_log(String peer_uid);
    tamed void send_peer(String peer_uid, Json msg);
    void broadcast_commit(lognumber_t from_storeno);
    template <typename T> void process_at_number(T number, std::deque<std::pair<T, tamer::event<> > >& list);

    tamed void listen_loop();
    tamed void connection_handshake(Vrchannel* peer, bool active_end);
    tamed void connection_loop(Vrchannel* peer);
    tamed void primary_keepalive_loop();
    tamed void backup_keepalive_loop();
};

template <typename T>
void Vrnode::process_at_number(T number, std::deque<std::pair<T, tamer::event<> > >& list) {
    for (auto it = list.begin(); it != list.end(); ++it)
        if (number >= it->first)
            it->second();
    while (!list.empty() && !list.front().second)
        list.pop_front();
}

std::ostream& operator<<(std::ostream& out, const timeval& tv);

inline std::ostream& Vrnode::log() const {
    std::cerr << tamer::recent() << ":" << uid() << ": ";
    return std::cerr;
}

inline std::ostream& Vrnode::log_connection(Vrchannel* ep, const char* ctype) const {
    std::cerr << tamer::recent() << ":" << uid() << ctype << ep->remote_uid();
    if (ep->connection_uid())
        std::cerr << " (" << ep->connection_uid() << ")";
    std::cerr << ": ";
    return std::cerr;
}

inline std::ostream& Vrnode::log_send(Vrchannel* ep) const {
    return log_connection(ep, " -> ");
}

inline std::ostream& Vrnode::log_receive(Vrchannel* ep) const {
    return log_connection(ep, " <- ");
}

inline std::ostream& Vrnode::log_connection(Vrchannel* ep) const {
    return log_connection(ep, " <-> ");
}

#endif
