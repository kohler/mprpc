// -*- mode: c++ -*-
#ifndef MPVR_THH
#define MPVR_THH 1
#include "string.hh"
#include "circular_int.hh"
#include <unordered_map>
#include <iostream>
using tamer::event;

class Vrendpoint {
  public:
    inline Vrendpoint(String local_uid, String remote_uid)
        : local_uid_(std::move(local_uid)), remote_uid_(std::move(remote_uid)),
          connection_version_(0) {
    }
    virtual ~Vrendpoint() {
    }

    inline const String& local_uid() const {
        return local_uid_;
    }
    inline const String& remote_uid() const {
        return remote_uid_;
    }
    inline const String& connection_uid() const {
        return connection_uid_;
    }
    inline void set_connection_uid(String x) {
        connection_uid_ = std::move(x);
    }
    inline unsigned connection_version() const {
        return connection_version_;
    }
    virtual Json local_name() const;
    virtual Json remote_name() const;

    static String make_client_uid();
    static String make_replica_uid();

    virtual void connect(Json def, event<Vrendpoint*> done);
    virtual void receive_connection(event<Vrendpoint*> done);

    virtual void send(Json msg);
    virtual void receive(event<Json> done);
    virtual void close();

    void print_send(const Json& msg, const String& extra = String());
    void print_receive(const Json& msg, const String& extra = String());
    void print_receive(const Json& msg, const Json& extra);

  protected:
    String local_uid_;
    String remote_uid_;
    String connection_uid_;
    unsigned connection_version_;

    void print_message(bool issend, const Json& msg, const String& extra);
};


class Vrgroup {
  public:
    typedef circular_int<unsigned> viewnumber_t;
    typedef viewnumber_t::difference_type viewnumberdiff_t;
    typedef circular_int<unsigned> lognumber_t;
    typedef lognumber_t::difference_type lognumberdiff_t;

    Vrgroup(const String& group_name, Vrendpoint* me);

    String group_name() const {
        return group_name_;
    }
    String uid() const {
        return me_ ? me_->local_uid() : String();
    }
    viewnumber_t view_number() const {
        return cur_view_.viewno;
    }

    tamed void connect(Json peer_name, event<> done);
    tamed void join(Json peer_name, event<> done);

    void at_view(viewnumber_t viewno, tamer::event<> done);
    void at_store(lognumber_t storeno, tamer::event<> done);
    void at_commit(lognumber_t commitno, tamer::event<> done);

    void stop();
    void go();

    void dump(std::ostream&) const;

  private:
    String group_name_;

    struct view_member {
        String uid;
        Json peer_name;
        bool acked;
        bool confirmed;
        bool has_storeno;
        lognumber_t storeno;
        unsigned store_count;
        explicit view_member(Json peer_name)
            : uid(peer_name["uid"].to_s()), peer_name(peer_name),
              acked(false), confirmed(false),
              has_storeno(false), store_count(0) {
        }
    };

    struct view_type {
        viewnumber_t viewno;
        std::vector<view_member> members;
        int primary_index;
        int my_index;
        unsigned nacked;
        unsigned nconfirmed;

        view_type();
        static view_type make_singular(Json peer_name);

        inline unsigned size() const {
            return members.size();
        }
        inline unsigned f() const {
            return size() / 2;
        }
        inline bool me_primary() const {
            return primary_index == my_index;
        }
        inline view_member& primary() {
            return members[primary_index];
        }
        inline String primary_uid() const {
            return members[primary_index].uid;
        }

        inline int count(const String& uid) const;
        inline view_member* find_pointer(const String& uid);
        Json members_json() const;
        Json commits_json() const;
        bool assign(Json msg, const String& my_uid);
        //inline Json operator[](const String& uid) const;
        bool operator==(const view_type& x) const;
        bool operator!=(const view_type& x) const { return !(*this == x); }
        bool shared_quorum(const view_type& x) const;
        void prepare(String uid, const Json& payload);
        void clear_preparation();
        void add(Json peer_name, const String& my_uid);
        void advance();
        void account_commit(view_member* peer, lognumber_t commitno);
        bool account_all_commits();
    };

    view_type cur_view_;
    view_type next_view_;
    bool want_member_;

    Vrendpoint* me_;
    mutable std::unordered_map<String, Vrendpoint*> endpoints_;
    mutable std::unordered_map<String, tamer::event<> > connection_wait_;

    struct log_item {
        viewnumber_t viewno;
        String client_uid;
        unsigned client_seqno;
        Json request;
        log_item() {
        }
        log_item(viewnumber_t v, String cuid, unsigned cseqno, Json req)
            : viewno(v), client_uid(std::move(cuid)), client_seqno(cseqno),
              request(std::move(req)) {
        }
    };

    lognumber_t first_logno_;
    lognumber_t commitno_;
    lognumber_t complete_commitno_;
    lognumber_t broadcast_commitno_;
    std::deque<log_item> log_;

    bool next_view_sent_confirm_;

    bool stopped_;

    std::deque<std::pair<viewnumber_t, tamer::event<> > > at_view_;
    std::deque<std::pair<lognumber_t, tamer::event<> > > at_store_;
    std::deque<std::pair<lognumber_t, tamer::event<> > > at_commit_;

    // timeouts
    double primary_keepalive_timeout_;
    double backup_keepalive_timeout_;
    double view_change_timeout_;

    double commit_sent_at_;
    double primary_received_at_;

    inline bool is_primary() const {
        return cur_view_.me_primary();
    }
    inline bool in_view(viewnumber_t v) const {
        return cur_view_.viewno == v
            && (next_view_.viewno == v || !next_view_sent_confirm_);
    }
    inline bool between_views() const {
        return cur_view_.viewno != next_view_.viewno
            && next_view_sent_confirm_;
    }

    String unparse_view_state() const;

    Json view_payload(const String& peer_uid);
    void send_view(Vrendpoint* who, Json payload = Json(), Json seqno = Json());
    tamed void send_view(Json peer);
    tamed void start_view_change();
    void broadcast_view();
    void process_join(Vrendpoint* who, const Json& msg);
    void process_view(Vrendpoint* who, const Json& msg);
    void process_view_log_transfer(Json& payload);
    void process_request(Vrendpoint* who, const Json& msg);
    void process_replicate(Vrendpoint* who, const Json& msg);
    void process_commit(Vrendpoint* who, const Json& msg);
    void update_commitno(lognumber_t commitno);
    tamed void send_commit(Json peer_name, Json msg);
    void broadcast_commit(lognumber_t from_storeno);
    template <typename T> void process_at_number(T number, std::deque<std::pair<T, tamer::event<> > >& list);

    tamed void listen_loop();
    tamed void connection_loop(Vrendpoint* peer, bool active_end);
    tamed void primary_keepalive_loop();
    tamed void backup_keepalive_loop();
};

template <typename T>
void Vrgroup::process_at_number(T number, std::deque<std::pair<T, tamer::event<> > >& list) {
    for (auto it = list.begin(); it != list.end(); ++it)
        if (number >= it->first)
            it->second();
    while (!list.empty() && !list.front().second)
        list.pop_front();
}

#endif
