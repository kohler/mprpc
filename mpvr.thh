// -*- mode: c++ -*-
#ifndef MPVR_THH
#define MPVR_THH 1
#include "string.hh"
#include <unordered_map>
#include <iostream>
using tamer::event;

class Vrendpoint {
  public:
    inline Vrendpoint(String local_uid, String remote_uid)
        : local_uid_(std::move(local_uid)), remote_uid_(std::move(remote_uid)),
          connection_version_(0) {
    }
    virtual ~Vrendpoint() {
    }

    inline const String& local_uid() const {
        return local_uid_;
    }
    inline const String& remote_uid() const {
        return remote_uid_;
    }
    inline unsigned connection_version() const {
        return connection_version_;
    }
    virtual Json local_name() const;
    virtual Json remote_name() const;

    static String make_client_uid();
    static String make_replica_uid();

    //virtual bool connected() const;
    //virtual void connect(event<bool> done);
    virtual void connect(Json def, event<Vrendpoint*> done);
    virtual void receive_connection(event<Vrendpoint*> done);

    virtual void send(Json msg);
    virtual void receive(event<Json> done);

    void print_receive(const Json& msg, const String& extra = String());
    void print_receive(const Json& msg, const Json& extra);

  protected:
    String local_uid_;
    String remote_uid_;
    unsigned connection_version_;
};


class Vrgroup {
  public:
    typedef unsigned viewnumber_t;
    typedef int viewnumberdiff_t;
    typedef unsigned lognumber_t;
    typedef int lognumberdiff_t;

    Vrgroup(const String& group_name, Vrendpoint* me);

    String group_name() const {
        return group_name_;
    }
    String uid() const {
        return me_ ? me_->local_uid() : String();
    }
    viewnumber_t view_number() const {
        return cur_view_.viewno;
    }

    template <typename T>
    event<T> timeout(event<T> done) const {
        return tamer::add_timeout(3, done);
    }
    template <typename R, typename T>
    event<T> timeout(tamer::preevent<R, T>&& done) const {
        return tamer::add_timeout(3, std::move(done));
    }

    tamed void connect(Json peer_name, event<Vrendpoint*> done);
    tamed void join(Json peer_name, event<Vrendpoint*> done);

    void dump(std::ostream&) const;

  private:
    String group_name_;

    struct view_member {
        String uid;
        Json peer_name;
        bool acked;
        bool confirmed;
        bool has_storeno;
        lognumber_t storeno;
        unsigned store_count;
        explicit view_member(Json peer_name)
            : uid(peer_name["uid"].to_s()), peer_name(peer_name),
              acked(false), confirmed(false),
              has_storeno(false), store_count(0) {
        }
    };

    struct view_type {
        viewnumber_t viewno;
        std::vector<view_member> members;
        int primary_index;
        int my_index;
        unsigned nacked;
        unsigned nconfirmed;

        view_type();
        static view_type make_singular(Json peer_name);

        inline unsigned size() const {
            return members.size();
        }
        inline unsigned f() const {
            return size() / 2;
        }
        inline bool me_primary() const {
            return primary_index == my_index;
        }
        inline view_member& primary() {
            return members[primary_index];
        }
        inline String primary_uid() const {
            return members[primary_index].uid;
        }

        inline int count(const String& uid) const;
        inline view_member* find_pointer(const String& uid);
        Json members_json() const;
        Json commits_json() const;
        bool assign(Json msg, const String& my_uid);
        //inline Json operator[](const String& uid) const;
        bool operator==(const view_type& x) const;
        bool operator!=(const view_type& x) const { return !(*this == x); }
        bool shared_quorum(const view_type& x) const;
        void prepare(String uid, const Json& payload);
        void clear_preparation();
        void add(Json peer_name, const String& my_uid);
        void account_commit(view_member* peer, lognumber_t commitno);
        bool account_all_commits();
    };

    view_type cur_view_;
    view_type next_view_;
    bool want_member_;

    Vrendpoint* me_;
    mutable std::unordered_map<String, Vrendpoint*> endpoints_;
    mutable std::unordered_map<String, tamer::event<Vrendpoint*> > in_progress_;

    struct log_item {
        viewnumber_t viewno;
        String client_uid;
        unsigned client_seqno;
        Json request;
        log_item() {
        }
        log_item(viewnumber_t v, String cuid, unsigned cseqno, Json req)
            : viewno(v), client_uid(std::move(cuid)), client_seqno(cseqno),
              request(std::move(req)) {
        }
    };

    lognumber_t first_logno_;
    lognumber_t commitno_;
    std::deque<log_item> log_;

    bool next_view_sent_confirm_;

    static inline bool logno_less(lognumber_t a, lognumber_t b) {
        return (lognumberdiff_t) (a - b) < 0;
    }
    static inline bool logno_greater(lognumber_t a, lognumber_t b) {
        return (lognumberdiff_t) (a - b) > 0;
    }
    static inline bool viewno_less(viewnumber_t a, viewnumber_t b) {
        return (viewnumberdiff_t) (a - b) < 0;
    }
    static inline bool viewno_greater(viewnumber_t a, viewnumber_t b) {
        return (viewnumberdiff_t) (a - b) > 0;
    }

    Vrendpoint* primary(const view_type& v) const;
    inline Vrendpoint* primary() const {
        return primary(cur_view_);
    }
    inline bool is_primary() const {
        return cur_view_.primary_index == cur_view_.my_index;
    }
    inline bool between_views() const {
        return cur_view_.viewno != next_view_.viewno
            && next_view_sent_confirm_;
    }

    String unparse_view_state() const;

    Json view_payload(const String& peer_uid);
    void send_view(Vrendpoint* who, Json payload = Json(), Json seqno = Json());
    tamed void send_view(Json peer);
    void broadcast_view();
    void process_join(Vrendpoint* who, const Json& msg);
    void process_view(Vrendpoint* who, const Json& msg);
    void process_view_log_transfer(Json& payload);
    void process_request(Vrendpoint* who, const Json& msg);
    void process_replicate(Vrendpoint* who, const Json& msg);
    void process_commit(Vrendpoint* who, const Json& msg);
    void update_commitno(lognumber_t commitno);
    tamed void send_peer(Json peer_name, Json msg);
    void broadcast_peers(Json msg);

    tamed void listen_loop();
    tamed void interconnect_loop(Vrendpoint*);
};

#endif
