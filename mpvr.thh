// -*- mode: c++ -*-
#ifndef MPVR_THH
#define MPVR_THH 1
#include "string.hh"
#include "circular_int.hh"
#include <unordered_map>
#include <random>
#include <iostream>
using tamer::event;

class Vrchannel {
  public:
    inline Vrchannel(String local_uid, String remote_uid)
        : local_uid_(std::move(local_uid)), remote_uid_(std::move(remote_uid)),
          connection_version_(0) {
    }
    virtual ~Vrchannel() {
    }

    inline const String& local_uid() const {
        return local_uid_;
    }
    inline const String& remote_uid() const {
        return remote_uid_;
    }
    inline const String& connection_uid() const {
        return connection_uid_;
    }
    inline void set_connection_uid(String x) {
        connection_uid_ = std::move(x);
    }
    inline unsigned connection_version() const {
        return connection_version_;
    }
    virtual Json local_name() const;
    virtual Json remote_name() const;

    static String make_client_uid();
    static String make_replica_uid();

    virtual void connect(String peer_uid, Json peer_name,
                         event<Vrchannel*> done);
    virtual void receive_connection(event<Vrchannel*> done);

    virtual void send(Json msg);
    virtual void receive(event<Json> done);
    virtual void close();

  protected:
    String local_uid_;
    String remote_uid_;
    String connection_uid_;
    unsigned connection_version_;
};


class Vrconstants {
  public:
    double message_timeout;
    double client_message_timeout;
    double request_timeout;
    double handshake_timeout;
    double primary_keepalive_timeout;
    double backup_keepalive_timeout;
    double view_change_timeout;
    double retransmit_log_timeout;

    Vrconstants()
        : message_timeout(1),
          client_message_timeout(1.5),
          request_timeout(10),
          handshake_timeout(5),
          primary_keepalive_timeout(1),
          backup_keepalive_timeout(2),
          view_change_timeout(0.5),
          retransmit_log_timeout(2) {
    }
};

typedef circular_int<unsigned> viewnumber_t;
typedef viewnumber_t::difference_type viewnumberdiff_t;
typedef circular_int<unsigned> lognumber_t;
typedef lognumber_t::difference_type lognumberdiff_t;


struct Vrview {
    struct member_type {
        String uid;
        Json peer_name;
        bool acked;
        bool confirmed;

        explicit member_type(String peer_uid, Json peer_name)
            : uid(std::move(peer_uid)), peer_name(std::move(peer_name)),
              acked(false), confirmed(false),
              has_storeno_(false), store_count_(0) {
            assert(!this->peer_name["uid"] || this->peer_name["uid"] == uid);
            this->peer_name["uid"] = this->uid;
        }

        bool has_storeno() const {
            return has_storeno_;
        }
        lognumber_t storeno() const {
            return storeno_;
        }
        unsigned store_count() const {
            assert(has_storeno());
            return store_count_;
        }
        double store_changed_at() const {
            return store_changed_at_;
        }

      private:
        bool has_storeno_;
        lognumber_t storeno_;
        unsigned store_count_;
        double store_changed_at_;

        friend class Vrview;
    };

    viewnumber_t viewno;
    std::vector<member_type> members;
    int primary_index;
    int my_index;
    unsigned nacked;
    unsigned nconfirmed;

    Vrview();
    static Vrview make_singular(String peer_uid, Json peer_name);

    inline unsigned size() const {
        return members.size();
    }
    inline unsigned f() const {
        return size() / 2;
    }
    inline bool me_primary() const {
        return primary_index == my_index;
    }
    inline member_type& primary() {
        return members[primary_index];
    }

    inline int count(const String& uid) const;
    inline member_type* find_pointer(const String& uid);
    Json members_json() const;
    Json commits_json() const;
    bool assign(Json msg, const String& my_uid);
    //inline Json operator[](const String& uid) const;
    bool operator==(const Vrview& x) const;
    bool operator!=(const Vrview& x) const { return !(*this == x); }
    bool shared_quorum(const Vrview& x) const;
    void prepare(String uid, const Json& payload);
    void clear_preparation();
    void add(String uid, const String& my_uid);
    void advance();
    void account_commit(member_type* peer, lognumber_t commitno);
    bool account_all_commits();
};


class Vrreplica {
  public:
    struct log_item {
        viewnumber_t viewno;
        String client_uid;
        unsigned client_seqno;
        Json request;
        log_item() {
        }
        log_item(viewnumber_t v, String cuid, unsigned cseqno, Json req)
            : viewno(v), client_uid(std::move(cuid)), client_seqno(cseqno),
              request(std::move(req)) {
        }
        bool operator==(const log_item& x) const {
            return viewno == x.viewno && client_uid == x.client_uid
                && client_seqno == x.client_seqno
                && request.unparse() == x.request.unparse();
        }
    };


    Vrreplica(const String& group_name, Vrchannel* me, std::mt19937& rg);

    String group_name() const {
        return group_name_;
    }
    String uid() const {
        return me_ ? me_->local_uid() : String();
    }
    viewnumber_t view_number() const {
        return cur_view_.viewno;
    }

    tamed void connect(String peer_uid, event<> done);
    tamed void join(String peer_uid, event<> done);
    void join(String peer_uid, Json peer_name, event<> done);

    void at_view(viewnumber_t viewno, tamer::event<> done);
    void at_store(lognumber_t storeno, tamer::event<> done);
    void at_commit(lognumber_t commitno, tamer::event<> done);

    void stop();
    void go();

    inline lognumber_t first_logno() const {
        return first_logno_;
    }
    inline lognumber_t last_logno() const {
        return first_logno_ + log_.size();
    }
    inline lognumber_t commitno() const {
        return commitno_;
    }
    inline const log_item& log_entry(lognumber_t logno) const {
        size_t delta = logno - first_logno_;
        assert(delta < log_.size());
        return log_[delta];
    }

    void dump(std::ostream&) const;

    inline std::ostream& log() const;

  private:
    String group_name_;

    typedef Vrview view_type;
    view_type cur_view_;
    view_type next_view_;
    bool want_member_;

    Vrchannel* me_;
    mutable std::unordered_map<String, Vrchannel*> endpoints_;
    mutable std::unordered_map<String, tamer::event<> > connection_wait_;
    mutable std::unordered_map<String, Json> node_names_;

    lognumber_t first_logno_;
    lognumber_t commitno_;
    lognumber_t complete_commitno_;
    std::deque<log_item> log_;

    bool next_view_sent_confirm_;

    bool stopped_;

    std::deque<std::pair<viewnumber_t, tamer::event<> > > at_view_;
    std::deque<std::pair<lognumber_t, tamer::event<> > > at_store_;
    std::deque<std::pair<lognumber_t, tamer::event<> > > at_commit_;

    // timeouts
    Vrconstants k_;
    double commit_sent_at_;
    double primary_received_at_;
    std::mt19937& rg_;

    inline bool is_primary() const {
        return cur_view_.me_primary();
    }
    inline bool in_view(viewnumber_t v) const {
        return cur_view_.viewno == v
            && (next_view_.viewno == v || !next_view_sent_confirm_);
    }
    inline bool between_views() const {
        return cur_view_.viewno != next_view_.viewno
            && next_view_sent_confirm_;
    }
    inline double rand01() const {
        std::uniform_real_distribution<double> urd;
        return urd(rg_);
    }

    String unparse_view_state() const;

    Json view_payload(const String& peer_uid);
    void send_view(Vrchannel* who, Json payload = Json(), Json seqno = Json());
    tamed void send_view(String peer_uid);
    void initialize_next_view();
    tamed void start_view_change();
    void broadcast_view();
    void process_join(Vrchannel* who, const Json& msg);
    void process_view(Vrchannel* who, const Json& msg);
    void process_view_log_transfer(Json& payload);
    void process_request(Vrchannel* who, const Json& msg);
    void process_replicate(Vrchannel* who, const Json& msg);
    void process_commit(Vrchannel* who, const Json& msg);
    void update_commitno(lognumber_t commitno);
    inline Json commit_message(lognumber_t logno) const;
    Json commit_log_message(lognumber_t from_storeno) const;
    void send_commit_log(String peer_uid);
    tamed void send_peer(String peer_uid, Json msg);
    void broadcast_commit(lognumber_t from_storeno);
    template <typename T> void process_at_number(T number, std::deque<std::pair<T, tamer::event<> > >& list);

    tamed void listen_loop();
    tamed void connection_handshake(Vrchannel* peer, bool active_end);
    tamed void connection_loop(Vrchannel* peer);
    tamed void primary_keepalive_loop();
    tamed void backup_keepalive_loop();
};


class Vrclient {
  public:
    Vrclient(Vrchannel* me, std::mt19937& rg);
    ~Vrclient();

    tamed void connect(String peer_uid, Json peer_name, event<> done);
    inline void connect(String peer_uid, event<> done);
    tamed void request(Json req, event<Json> done);
    inline void request(Json req, event<> done);

  private:
    String uid_;
    unsigned client_seqno_;
    Vrchannel* me_;
    Vrchannel* channel_;
    Vrview view_;
    bool stopped_;
    std::deque<std::pair<unsigned, tamer::event<Json> > > at_response_;
    std::mt19937& rg_;

    tamed void connection_loop(Vrchannel* peer);
    void process_response(Json msg);
    void process_view(Json msg);
};


template <typename T>
void Vrreplica::process_at_number(T number, std::deque<std::pair<T, tamer::event<> > >& list) {
    for (auto it = list.begin(); it != list.end(); ++it)
        if (number >= it->first)
            it->second();
    while (!list.empty() && !list.front().second)
        list.pop_front();
}

inline void Vrclient::connect(String peer_uid, event<> done) {
    connect(peer_uid, Json::object("uid", peer_uid), done);
}

inline void Vrclient::request(Json req, event<> done) {
    request(std::move(req), tamer::rebind<Json>(done));
}

std::ostream& operator<<(std::ostream& out, const timeval& tv);

inline std::ostream& Vrreplica::log() const {
    std::cerr << tamer::recent() << ":" << uid() << ": ";
    return std::cerr;
}

inline std::ostream& log_connection(const Vrchannel* ep, const char* ctype) {
    std::cerr << tamer::recent() << ":"
              << ep->local_uid() << ctype << ep->remote_uid();
    if (ep->connection_uid())
        std::cerr << " (" << ep->connection_uid() << ")";
    std::cerr << ": ";
    return std::cerr;
}

inline std::ostream& log_send(const Vrchannel* ep) {
    return log_connection(ep, " -> ");
}

inline std::ostream& log_receive(const Vrchannel* ep) {
    return log_connection(ep, " <- ");
}

inline std::ostream& log_connection(const Vrchannel* ep) {
    return log_connection(ep, " <-> ");
}

#endif
